import * as functions from "firebase-functions";
import * as admin from "firebase-admin";
import {
  Clone,
  Coll,
  Docs,
  FieldMasks,
  FunctionParams,
  FunctionResult,
  GetSavedItems,
  Info,
  Metrics,
  Root,
  RTDB,
  Search,
} from "./constants/constants";
import {
  EmailTakenError,
  InvalidEmailError,
  InvalidPswdError,
  InvalidUidError,
  InvalidUsernameError,
  MissionFailedError,
  UidTakenError,
  UnauthenticatedError,
  UnsupportedQueryError,
} from "./constants/errors";
import {
  isAuthorized,
  isEmailOk,
  isPswdOk,
  isUidOk,
  isUsernameOk,
} from "./field_checks";
import { FirestoreUser, FirestoreUsername } from "./data_models/user";
import { firestore } from "firebase-admin";

export const setEmailKey = functions.https.onCall((data, context) => {
  data;
  context;
  /**
   * {@link email verification (add later, for now, just check if email matches regex (not strict))
   *  - when user is signing up, they need to verifiy their email
   *    - client:
   *      - on client, when user enters email, show button to validate, and field to enter key below
   *      - when validate email button is pressed, call this function with email as param
   *    - server (this function):
   *      - when email is received, add to rtdb pendingEmails child as: "[encodedEmail]: [verification code]" (IMPORTANT: need to encode email since some chars not valid for rtdb field paths)
   *      - send code to user's email
   *      - make sure that email key matches in rtdb during sign-up process (first thing)
   * }
   */
});

/**
 * create user
 *
 * data - (if any null or invalid, throw error, unless specified below)
 * - username
 * - email
 * - email confirmation
 * - uid - if null then doesn't matter, if not null check if valid
 * - password
 * - password confirmation
 *
 * procedure
 * 1. check data
 * 2. create auth instance
 * 3. create rtdb username
 * 4. create user doc & username doc
 * 5. set username
 * - in any case, inform failure & undo stuff that succeeded
 */
export const create_user = functions.https.onCall(async (data, ctxt) => {
  const raw_username: unknown = data[Info.item_name];
  const raw_uid: unknown = data[Info.id] ?? undefined;
  const raw_email: unknown = data[FunctionParams.email];
  const raw_pswd: unknown = data[FunctionParams.password];

  /** {@link phase_1: check params} */

  if (!isUsernameOk(raw_username)) throw new InvalidUsernameError();
  if (!isEmailOk(raw_email)) throw new InvalidEmailError();
  // if uid is undefined then random one is auto-generated by auth
  if (raw_uid != undefined && !isUidOk(raw_uid)) throw new InvalidUidError();
  if (!isPswdOk(raw_pswd)) throw new InvalidPswdError();

  /** {@link phase_2: create auth instance} */

  // create auth instance
  const user = await admin
    .auth()
    .createUser({
      email: raw_email as string,
      emailVerified: false, // need to do email verification (with key system in function above)
      uid: raw_uid as string,
      password: raw_pswd as string,
    })
    .catch((e) => {
      switch (e.code) {
        case "auth/uid-already-exists":
          throw new UidTakenError();
        case "auth/email-already-exists":
          throw new EmailTakenError();
        default:
          console.error("create_user: failed to create auth instance: ", e);
          throw new MissionFailedError();
      }
    });

  /** {@link phase_3: set username in rtdb & create user & username doc} */

  // user doc data
  const user_doc_data = FirestoreUser.initDocData({
    uid: user.uid,
    username: raw_username as string,
  });
  // username doc data
  const username_doc_data = FirestoreUsername.initDocData({
    uid: user.uid,
    username: raw_username as string,
  });
  const user_doc_ref = admin.firestore().doc(Coll.users + "/" + user.uid);
  const username_doc_ref = admin
    .firestore()
    .doc(Coll.usernames + "/" + raw_username);

  // TODO: make sure utf-8 errors caught when indexing (rig indexing function to not use graphemes, or add invalid utf-8 char code)
  //.

  // create user & username docs
  try {
    await admin.firestore().runTransaction(async (t) => {
      t.create(user_doc_ref, user_doc_data);
      t.create(username_doc_ref, username_doc_data);
    });
  } catch (e) {
    // if fail, delete user auth instance
    await deleteUser();
    console.error("create_user: failed to create user & username doc: ", e);
    throw new MissionFailedError();
  }

  // set username in rtdb
  try {
    await admin
      .database()
      .ref(RTDB.username + "/" + user.uid)
      .set(raw_username as string);
  } catch (e) {
    // if fail, delete user auth instance and delete user & username docs
    await deleteUser();
    await deleteDocs();
    console.error("create_user: failed to set username in rtdb: ", e);
    throw new MissionFailedError();
  }

  // functions for undoing stuff if following step fails
  async function deleteUser() {
    await admin
      .auth()
      .deleteUser(user.uid)
      .catch((e) => {
        console.error(
          "create_user: failed to delete user instance after something else failed: ",
          e
        );
      });
  }
  async function deleteDocs() {
    const batch = admin.firestore().batch();
    batch.delete(username_doc_ref);
    batch.delete(user_doc_ref);
    await batch.commit().catch((e) => {
      console.error(
        "create_user: failed to delete user & username docs after something else failed: ",
        e
      );
    });
  }
});

export const get_saved_items = functions.https.onCall(async (data, context) => {
  if (!isAuthorized(context)) throw new UnauthenticatedError();

  const uid = context.auth!.uid!;

  const type = data[GetSavedItems.type];
  // TODO: need to setup for lists when ready, Metrics.downloads not supported for lists (lists can't be downloaded)

  switch (type) {
    case GetSavedItems.type_saved_items_doc: {
      console.log("get_saved_items: getting saved items doc");
      // TODO: setup query type, and based on that, get either saved items doc or saved item clones (from metric, need offset too)
      const timestamp_seconds =
        data[FunctionParams.timestamp]?.[FunctionParams.timestamp_seconds] ?? 0;
      const timestamp_nanoseconds =
        data[FunctionParams.timestamp]?.[
          FunctionParams.timestamp_nanoseconds
        ] ?? 0;
      const timestamp_updated = new firestore.Timestamp(
        timestamp_seconds,
        timestamp_nanoseconds
      );
      const force_sound_query = Boolean(data[FunctionParams.force_sound_query]);

      let saved_sounds_query: firestore.Query = firestore()
        .collection(Coll.users)
        .doc(uid)
        .collection(Coll.user_saved);
      if (!force_sound_query) {
        saved_sounds_query = saved_sounds_query
          .where(
            `${Root.info}.${Info.timestamp_updated}`,
            "!=",
            timestamp_updated
          )
          .where(firestore.FieldPath.documentId(), "==", Docs.saved_sounds);
      }

      const sound_snap = await saved_sounds_query.get();

      return { [FunctionResult.sounds]: sound_snap.docs[0]?.data() };
    }
    case GetSavedItems.type_saved_items_timestamp_saved: {
      console.log("get_saved_items: getting timestamp saved");
      // get docs, returned in same order as ids passed
      // null is returned for nonexistent docs, # in future remove from users saved sounds doc
      const ids: string[] = data[GetSavedItems.ids];
      if (!Array.isArray(ids)) throw new UnsupportedQueryError();
      if (ids.length > 20) ids.length = 20;
      const refs = [];
      for (const id of ids) {
        if (typeof id !== "string") throw new UnsupportedQueryError();
        refs.push(firestore().collection(Coll.sounds).doc(id));
      }
      const snaps = await firestore().getAll(...refs);
      return {
        [FunctionResult.sounds]: snaps.map<firestore.DocumentData | null>(
          (doc) => (doc.exists ? doc.data()! : null)
        ),
      };
    }
    case GetSavedItems.type_saved_items_sort: {
      console.log("get_saved_items: getting items sort");
      // TODO: saved item clones query here
      const offset = data[Search.offset];
      let query = firestore()
        .collectionGroup(Coll.saves)
        .where(`${Root.clone}.${Clone.ids}`, "array-contains", uid);

      const metric = data[GetSavedItems.metric];
      if (
        typeof metric !== "string" ||
        !GetSavedItems.supported_metrics.includes(metric)
      )
        throw new UnsupportedQueryError();

      // order by total, uid for offset
      query = query
        .orderBy(`${Root.metrics}.${metric}.${Metrics.total}`, "desc")
        .orderBy(firestore.FieldPath.documentId(), "asc");
      query = query.select(...FieldMasks.public_sound_search);

      /// set query offset if available
      if (Array.isArray(offset) && offset.length === 2) {
        query = query.startAfter(...offset);
      }

      const result = await query.get();
      return {
        [FunctionResult.sounds]: result.docs.map<firestore.DocumentData>(
          (doc) => doc.data()
        ),
      };
    }
    default:
      throw new UnsupportedQueryError();
  }
});
